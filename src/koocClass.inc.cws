function	addClass(theBlock : node, class : value, theLegacy : value)
{
  if (!existVariable(theBlock.classes[class]))
    {
      insert theBlock.classes[class] = class;
      local  newBlock;

      cnormPatchInit(newBlock);
      cnormPatchDeclaration(newBlock, "typedef struct _class_" + class + "_ { void* vtable; }" + class + ";");
      if (theLegacy != "")
	{
	  cnormPatchDeclaration(newBlock, "struct _vtable_" + class + "_ { struct _vtable_" + theLegacy + "_* vtableLegacy; } vt" + class + ";");
	  insert newBlock.block[0].legacy = theLegacy;
	}
      else
	cnormPatchDeclaration(newBlock, "struct _vtable_" + class + "_ {} vt" + class + ";");
      pushItem theBlock;
      setall theBlock#back = newBlock.block[0];
      ref theBlock.classes[class] = theBlock#back;
      insert theBlock.types[class];
      ref theBlock.types[class] = theBlock#back;
      pushItem theBlock;
      setall theBlock#back = newBlock.block[1];

      insert theBlock.types[class].vtable;
      ref theBlock.types[class].vtable = theBlock#back;
    }
  else
    error("/!\\ Redefinition of class '" + class + "' /!\\");
}

function	koocClassNameVar(theClass : value, theBlock : node, theExpression : value)
{
  local		newCode;
    
  cnormPatchInit(newCode);
  cnormPatchDeclaration(newCode, theExpression);

  if (koocDecorTool_gettype(newCode.block[0].ctype) == "struct"
      || koocDecorTool_gettype(newCode.block[0].ctype) == "union"
      || koocDecorTool_getinfoType(newCode.block[0].ctype.infoType) == "typedef"
      || koocDecorTool_getinfoType(newCode.block[0].ctype.infoType) == "static"
      || koocDecorTool_gettype(newCode.block[0].ctype) == "enum");
  else
    {
      local		name = newCode.block[0].name;
      newCode.block[0].name = "M_" + lengthString(theClass) + theClass + "_" + koocDecorTool_getsymtype(newCode.block[0].type);
      newCode.block[0].name = koocDecorPrim(newCode.block[0], name);

      foreach class in theBlock
      {
	if (class.ctype.identifier == "_class_" + theClass + "_")
	  {
	    pushItem class.ctype.list;
	    setall class.ctype.list#back = newCode.block[0];
	  }
      }
    }
}

function	koocClassNameFunc(theClass : value, theBlock : node, theExpression : value, theVirtual : value)
{
  local newCode;
  cnormPatchInit(newCode);
  cnormPatchDeclaration(newCode, "typedef struct _class_" + theClass + "_ " + theClass + ";");
  cnormPatchDeclaration(newCode, theExpression);

  if (koocDecorTool_gettype(newCode.block[1].ctype) == "struct"
      || koocDecorTool_gettype(newCode.block[1].ctype) == "union"
      || koocDecorTool_getinfoType(newCode.block[1].ctype.infoType) == "typedef"
      || koocDecorTool_getinfoType(newCode.block[1].ctype.infoType) == "static"
      || koocDecorTool_gettype(newCode.block[1].ctype) == "enum");
  else
    {
      local		name = newCode.block[1].name;

      if (theVirtual == "" || theVirtual == "@member")
      	newCode.block[1].name = "M_" + lengthString(theClass) + theClass + "_" + koocDecorTool_getsymtype(newCode.block[1].type);
      else
      	newCode.block[1].name = "V_" + lengthString(theClass) + theClass + "_" + koocDecorTool_getsymtype(newCode.block[1].type);
      newCode.block[1].name = koocDecorPrim(newCode.block[1], name);

      local expr;
      cutString(theExpression, "(", expr);

      local func;      
      cnormPatchInit(func);
      cnormPatchDeclaration(func, "typedef struct _class_" + theClass + "_ " + theClass + ";");
      
      foreach vtable in theBlock
      {
      	if (vtable.ctype.identifier == "_vtable_" + theClass + "_") 
      	  {
	    local type = "";
	    theExpression = "(*" + newCode.block[1].name + ")(" + theClass + "*";

	    foreach info in newCode.block[1].ctype.infoType
	      type = type + key(info) + " ";
	    type = type + newCode.block[1].ctype.identifier + " ";
	    foreach point in newCode.block[1].ctype.pointer
	      type = type + "*";

	    if (expr[1] == "void);" || expr[1] == ");")
	      cnormPatchDeclaration(func, type + theExpression + ");");
	    else
	      cnormPatchDeclaration(func, type + theExpression + ", " + expr[1]);
	    
      	    pushItem vtable.ctype.list;
      	    setall vtable.ctype.list#back = func.block[1];
      	  }
      }
    }
}

function	setNodeLegacy(theAst : node, theLegacyName : value, theChildBlock : reference)
{
  foreach file in theAst
  {
    foreach declaration in file.block
    {
      if (equalsIgnoreCase(declaration.ctype.identifier, theLegacyName))
	foreach block in declaration.ctype.list
	{
	  if (block.name != "vtable")
	    {
	      pushItem theChildBlock;
	      setall theChildBlock#back = block;
	    }
	}
    }
  }
}

function	koocClassRecScan(theFile : node, theAst : node)
{
  foreach declaration in theFile.block
  {
    if (existVariable(declaration.ctype.identifier) && startString(declaration.ctype.identifier, "_class_"))
      if (existVariable(declaration.legacy))
	{
	  insert declaration.ctype.list;
	  setNodeLegacy(theAst, "_class_" + declaration.legacy + "_", declaration.ctype.list);
	}
  }
}

function	koocClassImpl(theClass : value, theBlock : node, theVirtual : value, FuncTable : reference)
{
  if (koocDecorTool_gettype(theBlock#back.ctype) == "struct"
      || koocDecorTool_gettype(theBlock#back.ctype) == "union"
      || koocDecorTool_getinfoType(theBlock#back.ctype.infoType) == "typedef"
      || koocDecorTool_getinfoType(theBlock#back.ctype.infoType) == "static"
      || koocDecorTool_gettype(theBlock#back.ctype) == "enum");
  else
    {
      local		name = theBlock#back.name;

      if (theVirtual == "" || theVirtual == "@member")
	theBlock#back.name = "M_" + lengthString(theClass) + theClass + "_" + koocDecorTool_getsymtype(theBlock#back.type);
      else
	theBlock#back.name = "V_" + lengthString(theClass) + theClass + "_" + koocDecorTool_getsymtype(theBlock#back.type);
      theBlock#back.name = koocDecorPrim(theBlock#back, name);

      invertArray(theBlock#back.list);
      pushItem theBlock#back.list;
      local newCode;
      cnormPatchInit(newCode);
      cnormPatchDeclaration(newCode, "typedef struct _class_" + theClass + "_ " + theClass + ";");
      cnormPatchDeclaration(newCode, theClass + "* self");
      setall theBlock#back.list#back = newCode.block[1];
      invertArray(theBlock#back.list);
    }

  if (theBlock#back.type == "__FUNCTION__") 
    pushItem FuncTable = theBlock#back.name;
}

function	koocClassCreateVtable(theClass : value, theBlock : node, FuncTable : reference)
{
  local		theExpression;
  local		newCode;

  foreach class in theBlock.classes
  {
    if (key(class) == theClass)
      {
	cnormPatchInit(newCode);

	theExpression = "struct _vtable_" + theClass + "_ vt" + theClass + " = {";

	foreach class in theBlock.classes
	{
	  if (key(class) == theClass)
	    if (existVariable(class.legacy))
	      {
		theExpression = theExpression + "&vt" + class.legacy;
		if (!isEmpty(FuncTable))
		  theExpression = theExpression + ", ";
	      }
	}

	foreach pointer in class.vtable.ctype.list
	{
	  foreach func in FuncTable
	  {
	    if (func == pointer.name)
	      {
		theExpression = theExpression + func;
		if (pointer.name != class.vtable.ctype.list#back.name)
		  theExpression = theExpression + ", ";
	      }
	  }
	}
	theExpression = theExpression + "};";

	cnormPatchDeclaration(newCode, theExpression);
	pushItem theBlock;
	setall theBlock#back = newCode.block[0];
      }
  }
}
